[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15248384&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

What is software engineering, and how does it differ from traditional programming?
Software engineering is the process of designing, developing,testing and maintenance of software .It is ensured that the software is reliable, efficient and meets user needs.
Differences between Software Engineering and Traditional Programming
Software engineering includes the software development lifecycle from analysis and design to implementation, testing and deployment of software while traditional programming involves the writing of code to solve  problems.
Software Engineering uses structured methods to manage complexity and ensure a seamless development ie. planning,modeling and documentation while Traditional Programming is less structured and may highly be dependent on an individual practices and preferences without a  formalized approach
Software Engineering involves collaboration among teams including developers,testers,project managers, designers where coordinated communication is key while Traditional Programming can be done with minimal team collaboration
Software Engineering emphasizes  on rigorous testing, code reviews, and quality assurance processes to ensure the software meets specified requirements and is free of defects while Traditional Programming has less emphasis on formal testing and focuses mainly on getting the code to work 
Software Development Life Cycle (SDLC):
Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
1.Planning: This initial phase involves defining the project scope, identifying resources, scheduling, and setting goals. Key activities include feasibility analysis, risk assessment, and project planning.
2.Requirement Analysis: In this phase, the specific requirements of the software are gathered and analyzed. This includes understanding the needs of the stakeholders, documenting requirements, and ensuring they are feasible.
3.Design: This phase involves creating the architecture of the software. High-level design focuses on system architecture, while low-level design covers detailed internal structure. The output is often design documents and UML diagrams.
4.Implementation (Coding): This is the phase where actual coding happens. Developers write code according to the specifications and design documents created in the previous phases.
5.Testing: After coding, the software undergoes various levels of testing (unit testing, integration testing, system testing, acceptance testing) to identify and fix defects. The goal is to ensure the software meets the requirements and is free of bugs.
6.Deployment: Once the software is tested and approved, it is deployed to the production environment where it will be used by the end-users. Deployment can be done in stages or all at once, depending on the project requirements.
7.Maintenance: Post-deployment, the software enters the maintenance phase, which involves correcting any issues that arise, making necessary updates, and enhancing the software with new features based on user feedback.

Agile vs. Waterfall Models:

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Requirements Engineering:
Key Differences:
Waterfall model uses a sequential and linear approach where each phase has to be completed before moving to the next while agile uses iterative and incremental approach which development occurs in cycles with regular adjustments
Waterfall has low flexibility in that changes are difficult and costly once a phase is completed while agile has high flexibility and it's easy to make changes at any stage 
Waterfall requirements are defined upfront and are expected to stay the same while agile requirements are evolving because of the anticipated changes .
Waterfall testing is done after development phase is completed while in agile testing is integrated throughout the development cycle.
Waterfall has limited customer involvement while agile has high customer involvement throughout the process 
Waterfall emphasizes on  comprehensive documentation at each stage while agile emphasizes working software over documentation, although necessary documentation is still maintained.

Waterfall Model is preferred:
When project requirements are well-understood, stable, and unlikely to change.
Projects with clear deliverables and outcomes.
Projects that require extensive documentation and adherence to regulatory standards 
 Projects where predictability in timelines and budgets is crucial.

Agile Model is preferred :

 Projects where requirements are expected to change or are not fully known at the start.
 Projects that benefit from continuous customer or stakeholder feedback.
Projects that require rapid development and delivery of a product.
Suitable for projects with high complexity and uncertainty where iterative development can help manage risk.

Requirements Engineering:
What is requirements engineering? Describe the process and its importance in the software development lifecycle.

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Software Design Principles:
Requirements engineering is a  phase in the software development lifecycle (SDLC) that involves identifying, documenting, and managing the needs and requirements of stakeholders for a software system. The process ensures that the final product meets the intended purpose and user expectations.
Process in requirements engineering:
Requirements elicitation: The aim is to gather information on what stakeholders need from the system. Information is gathered through interviews, questionnaires, user observation, workshops, brainstorming sessions, use cases, and scenarios
Requirements Analysis:Focuses on analyzing and refining the gathered requirements to ensure they are clear,complete,consistent and lack ambiguity .This is done by identifying conflicts among requirements,prioritizing the requirements and ensuring feasibility 
Requirements Specification:Documenting the requirements in a detailed structured manner .Requirements Specification Document (RSD), which may include functional requirements, non-functional requirements, user requirements, system requirements, and interface requirements.
Requirements Validation and Verification: Ensures requirements accurately represnt stakeholders needs and specifications are correct. Methods used include reviews, inspections, walkthroughs and prototyping
Requirements Management:Handle changes to the requirements throughout the project lifecycle. This involves the use of version control, traceability, impact analysis, and change management.
Importance of Requirements Engineering in the SDLC:

Ensures that the final product meets the stakeholders' expectations and requirements, leading to higher user satisfaction
Early identification and resolution of issues and conflicts in requirements can prevent costly revisions and rework later in the development process
Clear, detailed, and well-validated requirements lead to the development of a higher-quality product with fewer defects.
Provides a clear scope of the project, aiding in better planning, estimation, and resource allocation.
Creates a common understanding among stakeholders, developers, and project managers, reducing misunderstandings and ensuring everyone is on the same page.
Involves identifying potential issues early in the requirements phase and allows for risk assessment and mitigation strategies to be implemented.

Software Design Principles:

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
